Server BUS
==========
As mensagens são entregues debaixo de tópicos (tipo de mensagem). As mensagens de um topico têm todas a mesma estrutura de dados.

Mensagem:
---------
+Version: version of the data structure
+Kind: NONE, REQUEST, REPLY, ERROR
+msgId: message id for this connection
+msgUTC: UTC
+action: ASK, PUB, QUEUE, ...
+name: Topic Name: /systemA/North
+headers: map[string]string
+payload: bytes (encode/decode)
?+brokerId:
?+senderId:
?+CRC:

1 fase)
#Publish/Subscribe#
x O cliente regista-se no servidor.
x O Servidor recebe registo e cria thread para escutar pedidos do cliente.
x O Cliente indica qual o grupo de mensagens que quer escutar.
x O servidor regista debaixo do grupo de mensagens, os clientes que respeitam a regra
x O Cliente envia mensagem (publish)
x O Servidor lê a mensagem e reenvia a mensagem (broadcast) para todos os clientes interessados, em novas threads.
x O cliente tenta religar-se sempre que a ligação é interrompida.
  TODO: a nova ligação deve ser obtida através de um "directorio". (NLB)

#queuing
x igual a publish-subscribe mas só um consumidor recebe a mensagem (random/shuffle?).

2 fase)
#Request/Reply (single/multiple)#
. single Reply (só interessa a resposta de um dos providers)
----------------
Cenário: Vários providers para um determinado serviço, em que cada um tem um conjunto de informação distinta mas que formam um todo, e só um deve responder com a informação.
ex: DTCs estão instalados em dois polos isolados, e existem uma terceira parte que quer informação sobre um DTC, mas não sabe a que polo pertence o DTC.

x Um evento chega ao broker
x O broker pergunta aos providers especificos se estão interessados em responder - ASK:<EVENT_NAME>
x Os providers respondem "true" se estão interessados ou "false" se não
x Às respostas "false" não é dado seguimento
x O primeiro cliente a responder "true", será o que irá processar o request, sendo-lhe enviado o REQUEST.
x Se não houver resposta do cliente (timeout ou outro), usa-se o cliente seguinte.
x Após uma resposta com sucesso, as respostas "true" dos restantes clientes serão ignoradas.

. multiple Reply
----------------
as respostas dos vários providers são entregues à callback ao mesmo tempo na forma de uma array.

Os mesmos passos do single Reply até ao ponto 4, inlusivé.
x as repostas intermedias são identificadas como tal e a ultima resposta é uma resposta normal (identifica o fim).
x O requerente acumula as várias respostas numa array, até receber a ultima resposta.
x Entrega a array à callback.
x O requerente remove a callback

TODO: Broker Listeners
----------------------
Subscribers especiais que escutam multiplos eventos baseados em wildcards (talvez regular expressions). 
ex: "/scada/digital/*" -> escuta eventos do tipo "/scada/digital/d1", "/scada/digital/abc", ...

3 fase)
#Cluster#
- Um cluster é constituido por vários brokers (nós), tendo à frente um balanceador de carga (NLB), ou um HA Proxy.
- Um cluster tem um identificador unico conhecido por todos os nós. Permite a convivencia de cluster distintos na mesma rede.
- Todos os nós do cluster são iguais.
- Sempre que um nó fica online, anuncia-se. O outros nós reagem estabelecendo ligações ao novo nó, que por sua vez estabelece uma ligação inversa.
- Quando um cliente ligado a um broker subescreve um tópico, esse broker anuncia-se aos outros brokers como subscriber desse tópico.
- No que respeita à troca de eventos, os nós são vistos como clientes uns dos outros. 
	As mensagens reenviadas aos brokers têm que levar a indicação que dali, só podem seguir para clientes. Ou seja, entre brokers, só pode haver UM reencaminhamento, eliminando o risco de as mensagens circularem em loop inifinito entre os clusters.

4 fase)
#PERSISTENCIA DE MENSAGENS
- Um broker pode ter um mirror (nó que vai ter uma replica dos eventos e o registos dos clientes)
- Um broker guarda numa lista os eventos entregues (só os marcados para serem persistidos), por um periodo de tempo máximo (ex: 1 dia).
- Uma lista por cada tópico.
- Cada evento é registado com um número sequencial unico dentro do tópico. Esse número faz parte do envelope enviado ao consumidor, juntamente com o guid do broker original.
- O consumidor mantem o registo do guid do brokers e do número sequencial da última mensagem recebida.
- Quando uma mensagem é entregue com sucesso a um broker - ocorrendo replica do evento para o mirror - este envia um ACK ao cliente indicando que tudo correu bem.
- Um evento de mirror não provoca broadcast.

NOTA: para registar as mensagens usar buckets de ficheiros em vez de BD, ja que a persistencia é linear. 
    
NOTA: PARA REQUEST/REPLY, NÃO HÁ PERSISTENCIA DAS MENSAGENS. SE UM NÓ DO CAMINHO FALHA, TODO O PROCESSO FALHA (TIMEOUT). É NECESSÁRIO TENTAR OUTRA VEZ.
	
Casos de uso:
» Um cliente envia mensagem não persistente

» Um cliente envia mensagem persistente
	- O broker recebe mensagem
	- persiste mensagem (grava em disco e envia mensagem ao mirror)
	- o broker entrega a mensagens aos consumidores interessados
	- se um broker recebe /reencaminha mensagem
	- Devolve ACK ao produtor da mensagem
	- Se houver algum erro o cliente volta a enviar a mensagem
	- mensagens duplicadas são descartadas pelos clientes consumidores?????

» Cliente novo liga-se a um broker:
	- Um cliente liga-se a um broker.
	- O broker atribui um numero sequencial ao cliente (clientNo).
	- O cliente diz quais os tópicos que pretende receber e fica à escuta.

» Um cliente antigo retorna:
	- O cliente liga-se a um broker.
	- O broker atribui um numero sequencial ao cliente (clientNo).
	- O cliente envia ao broker a lista de topicos que quer escutar, juntamente com uma lista dos ultimos brokerId/topic/msgNo das mensagens persistentes que recebeu. Este ultimos permitem que o broker saiba como encaminhar os eventos que venham a imediatamente seguir à entrega do último evento pendente. O broker deste cliente (consumer) irá descartar eventos normais persistentes vindos de um broker e tópico sobre o qual está a decorrer um ciclo de consumo de pendentes. Estes eventos não são perdidos pois como estão a ser persistidos, eventualmente serão entregues. Assim que a ultima mensagem pendente é recebida, para um broker/topico, o broker deixa de descartar mensagens.
	- O broker, usando o guid-msgNo fornecido, começa a questionar os brokers do cluster. Se um broker não for encontrado (offline), todos os brokers são questionados para aquele brokerId.
	- O broker que recebe o pedido de mensagens persistidas, lança uma goroutine para processar, um/cem a um/cem, os eventos em log a partir do msgNo fornecido.
	- O envelope da mensagem criada contem a informação do broker guid e do clientNo para o correto encaminhamento. Só o cliente que pediu é que recebe as mensagens.
	- O último evento da lista a ser enviado é indicado como o ultimo.
	- A partir daqui os próximos eventos persistentes são tratados normalmente.
        - Durante este ciclo de pendentes, os eventos não persistentes foram sempre consumidos normalmente.

- Um broker mirror fica online
	- descarta log anterior de mensagens
	- gera novo guid
	- Pede ao mirror o log do mirror (Nota podemos estar a falar de GBs).

- Um broker fica offline imediatamente a seguir a receber uma mensagem e enviar o ACK ao cliente.
	- O broker mirror, apercebe-se da falha e fica ele a responder a pedidos de mansagens pendentes (replay).

==============================================
	
Melhorias:
- O grupo de mensagens pode ser hierarquico. 
	ex: escutar mensagens do tipo "/state/machine/*" indica interesse em escutar mensagens que comecem por "/state/machine/".
- As mensagens podem ter scope: Local, Remoto ou Global
	Local: só mensagens para clients registados no mesmo nó.
	Remoto: ...
	Global: ...
- Aplicar autenticação/autorização
